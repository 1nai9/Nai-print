<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Ù…ÙˆÙ‚Ø¹ Ø±Ø³Ù… - Ø·Ø¨Ù‚Ø§Øª Ù…Ù†Ø¨Ø«Ù‚Ø©</title>
  <style>
    :root{
  --bg:#03040a;
  --control-bg: rgba(10,10,20,0.9);
  --panel-bg: rgba(10,10,30,0.2);
  --accent:#00e5ff;
  --layer-panel-bg: rgba(10,10,30,0.88);
  --shadow: 0 8px 30px rgba(0,229,255,0.2);
}

html,body{
  height:100%;
  margin:0;
  font-family:'Poppins',sans-serif;
  background:var(--bg);
  color:#e7f4ff;
}

.app{
  height:100vh;
  display:flex;
  flex-direction:column;
  gap:8px;
  padding:10px;
  box-sizing:border-box;
}

/* Top bar */
.topbar{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:1px;
  padding:3px 3px;
}
.top-left,.top-right{
  display:flex;
  gap:1px;
  align-items:center;
}
.title{
  font-size:17px;
  color:var(--accent);
  padding:4px 10px;
  border-radius:12px;
  background:rgba(0,0,0,0.6);
  box-shadow:var(--shadow);
}
.icon-btn{
  width:40px;
  height:40px;
  border-radius:12px;
  background:var(--control-bg);
  display:inline-flex;
  align-items:center;
  justify-content:center;
  box-shadow:var(--shadow);
  border:none;
  cursor:pointer;
  color:var(--accent);
  font-weight:700;
  font-size:18px;
}

/* Main area */
.main{
  display:flex;
  gap:8px;
  flex:1;
  align-items:stretch;
  position:relative;
}
.canvas-area{
  flex:1;
  display:flex;
  flex-direction:column;
  gap:8px;
}
.canvas-wrap{
  position:relative;
  flex:1;
  border-radius:16px;
  overflow:hidden;
  background:linear-gradient(180deg,#0a0b14 0%, #0a0b14 40%, #03040a 100%);
  box-shadow:0 0 15px var(--accent) inset;
}
.layer-canvas{
  position:absolute;
  left:0;
  top:0;
  width:100%;
  height:100%;
  touch-action:none;
}

/* Layers flyout */
.layers-flyout{
  position:absolute;
  top:12px;
  right:12px;
  width:160px;
  max-height:70vh;
  background:var(--layer-panel-bg);
  border-radius:16px;
  box-shadow:var(--shadow);
  transform: translateX(110%);
  transition: transform 260ms ease;
  opacity:0;
  z-index:1200;
  backdrop-filter: blur(6px);
  display:flex;
  flex-direction:column;
  padding:8px;
  gap:8px;
}
.layers-flyout.open{
  transform: translateX(0);
  opacity:1;
}
.layers-header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:6px;
  color:#e7f4ff;
}
.layers-list{
  display:flex;
  flex-direction:column;
  gap:6px;
  overflow:auto;
  padding-right:4px;
}
.layer-item{
  display:flex;
  align-items:center;
  gap:6px;
  padding:6px;
  border-radius:8px;
  background:rgba(0,10,30,0.5);
  cursor:pointer;
  justify-content:space-between;
}
.layer-item.active{
  outline:2px solid var(--accent);
  background:rgba(0,229,255,0.1);
}
.layer-thumb{
  width:44px;
  height:30px;
  border-radius:6px;
  background:#0a0b14;
  flex-shrink:0;
  overflow:hidden;
  border:1px solid rgba(0,229,255,0.1);
}
.layer-name{
  font-size:13px;
  text-align:right;
  flex:1;
  padding-right:6px;
}
.layer-actions, .small-btn{
  display:flex;
  flex-direction:column;
  gap:6px;
  padding:6px;
  border-radius:8px;
  background:#0a0b14;
  border:1px solid rgba(0,229,255,0.2);
  font-size:13px;
  color:#e7f4ff;
  cursor:pointer;
}

/* Toolbar */
.toolbar{
  display:flex;
  gap:0px;
  align-items:center;
  justify-content:space-between;
  padding:0px;
}
.tools{
  display:flex;
  gap:4px;
  align-items:center;
}
.control{
  background:var(--control-bg);
  padding:0px;
  border-radius:12px;
  box-shadow:var(--shadow);
  display:flex;
  gap:4px;
  align-items:center;
}
.color-pill{
  width:34px;
  height:34px;
  border-radius:8px;
  border:1px solid rgba(0,229,255,0.2);
}

/* Range */
input[type=range]{
  width:110px;
}

/* Menu popup */
.menu-popup{
  position:absolute;
  bottom:46px;
  right:0;
  background:var(--control-bg);
  padding:8px;
  border-radius:12px;
  box-shadow:var(--shadow);
  display:none;
  flex-direction:column;
  gap:6px;
  width:180px;
  z-index:50;
}
.menu-popup.show{display:flex;}

/* Shape preview */
#shapePreview{
  position:absolute;
  left:0;
  top:0;
  z-index:900;
  pointer-events:none;
}

/* Responsive */
@media (max-width:520px){
  .layers-flyout{width:140px}
  input[type=range]{width:80px}
  .icon-btn{width:38px;height:38px}
}
</style>
</head>
<body>
  <div class="app">
    <div class="topbar">
      <div class="top-left">
        <button class="icon-btn" id="homeBtn" title="Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©">ğŸ </button>
        <div class="title">Nai print</div>
      </div>

      <div class="top-right">
        <!-- Ø²Ø± Ø§Ù„Ø£Ø¯ÙˆØ§Øª (Ø£Ø¹Ù„Ù‰) -->
        <button class="icon-btn" id="shapesTopBtn" title="Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø£Ø´ÙƒØ§Ù„">â‹¯</button>
        <div id="saveBtn" class="menu-item"></div>

        <!-- Ø²Ø± Ø§Ù„Ø·Ø¨Ù‚Ø§Øª (ÙŠÙØªØ­ Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ù…Ù†Ø¨Ø«Ù‚Ø© Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ†) -->
        <button class="icon-btn" id="layersToggle" title="Ø§Ù„Ø·Ø¨Ù‚Ø§Øª">ğŸ“š</button>
      </div>
    </div>

    <div class="main">
      <div class="canvas-area">
        <div class="canvas-wrap" id="canvasWrap">
          <!-- layer canvases ÙŠØ¶Ø§ÙÙˆÙ† Ù‡Ù†Ø§ -->
          <canvas id="shapePreview"></canvas>
        </div>

        <div class="toolbar">
          <div class="tools">
            <div class="control" role="toolbar">
              <button class="icon-btn" id="brushBtn" title="Ù‚Ù„Ù…">âœï¸</button>
              <button class="icon-btn" id="eraserBtn" title="Ù…Ù…Ø­Ø§Ø©">ğŸ§½</button>
              <button class="icon-btn" id="fillBtn" title="Ø§Ù„Ø¯Ù„Ùˆ">ğŸª£</button>

              <div style="display:flex;flex-direction:column;align-items:center">
                <input type="color" id="colorPicker" class="color-pill" value="#ffffff"/>
                <div style="font-size:11px;color:#444;margin-top:-4px">Ù„ÙˆÙ†</div>
              </div>

              <div style="display:flex;flex-direction:column;align-items:center;margin-inline-start:6px">
                <input type="range" id="sizeRange" min="1" max="80" value="6" />
                <div style="font-size:8px;color:#444;margin-top:-9px">Ø­Ø¬Ù…</div>
                
                <div style="display:flex;flex-direction:column;align-items:center;margin-inline-start:6px">
  <input type="range" id="brushAlpha" min="0.05" max="1" step="0.05" value="1"/>
  <div style="font-size:8px;color:#444;margin-top:-9px">Ø´ÙØ§ÙÙŠØ© Ù‚Ù„Ù…</div>
</div>
              </div>
            </div>

            <div class="control">
              <button class="icon-btn" id="undoBtn" title="ØªØ±Ø§Ø¬Ø¹">â¤º</button>
              <button class="icon-btn" id="redoBtn" title="Ø¥Ø¹Ø§Ø¯Ø©">â¤»</button>
              <button class="icon-btn" id="clearBtn" title="Ù…Ø³Ø­">ğŸ—‘ï¸</button>
            </div>
          </div>


          </div>
        </div>
      </div>

      <!-- Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ù…Ù†Ø¨Ø«Ù‚Ø© Ù„Ù„Ø·Ø¨Ù‚Ø§Øª (C: narrow slide-in from right) -->
      <div class="layers-flyout" id="layersFlyout" aria-hidden="true">
        <div class="layers-header">
          <div style="font-weight:700">Ø§Ù„Ø·Ø¨Ù‚Ø§Øª</div>
          <div style="display:flex;gap:6px;align-items:center">
            <button id="addLayerBtn" class="small-btn" title="Ø¥Ø¶Ø§ÙØ©">+</button>
            <button id="closeLayersBtn" class="small-btn" title="Ø¥ØºÙ„Ø§Ù‚">Ã—</button>
          </div>
          
        </div>
        <div class="layers-list" id="layersList"></div>
        <div style="display:flex;gap:6px;justify-content:space-between">
          <button id="raiseBtn" class="small-btn" title="Ø±ÙØ¹ Ø§Ù„Ø·Ø¨Ù‚Ø©">â†‘ Ø±ÙØ¹</button>
          <button id="lowerBtn" class="small-btn" title="Ø®ÙØ¶ Ø§Ù„Ø·Ø¨Ù‚Ø©">â†“ Ø®ÙØ¶</button>
          <button id="deleteBtn" class="small-btn" title="Ø­Ø°Ù Ø§Ù„Ø·Ø¨Ù‚Ø©">ğŸ—‘ï¸ Ø­Ø°Ù</button>
        </div>
        <div style="display:flex;flex-direction:column;align-items:center;margin-inline-start:6px">
  <input type="range" id="layerAlpha" min="0" max="1" step="0.05" value="1"/>
  <div style="font-size:8px;color:#444;margin-top:-9px">Ø´ÙØ§ÙÙŠØ© Ø·Ø¨Ù‚Ø©</div>
</div>
      </div>
    </div>
  </div>

<script>
  
  function saveDrawing(){
  const rect = wrap.getBoundingClientRect();
  const tmp = document.createElement('canvas');
  tmp.width = Math.round(rect.width * devicePixelRatioVal);
  tmp.height = Math.round(rect.height * devicePixelRatioVal);
  tmp.style.width = rect.width+'px';
  tmp.style.height = rect.height+'px';
  const tctx = tmp.getContext('2d');
  tctx.setTransform(devicePixelRatioVal,0,0,devicePixelRatioVal,0,0);
  tctx.fillStyle = '#ffffff';
  tctx.fillRect(0,0,rect.width,rect.height);
  
  

  layers.forEach(l=>{
    if (!l.visible) return;
    tctx.globalAlpha = l.opacity || 1;
    tctx.drawImage(l.canvas,0,0,rect.width,rect.height);
  });

  tmp.toBlob(blob=>{
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'drawing.png';
    a.click();
    URL.revokeObjectURL(a.href);
  }, 'image/png');
}

/* ====== Ø¹Ù†Ø§ØµØ± DOM ====== */
const wrap = document.getElementById('canvasWrap');
const shapePreview = document.getElementById('shapePreview');

const brushBtn = document.getElementById('brushBtn');
const eraserBtn = document.getElementById('eraserBtn');
const colorPicker = document.getElementById('colorPicker');
const sizeRange = document.getElementById('sizeRange');
const undoBtn = document.getElementById('undoBtn');
const redoBtn = document.getElementById('redoBtn');
const clearBtn = document.getElementById('clearBtn');
const saveBtn = document.getElementById('saveBtn');

const shapesTopBtn = document.getElementById('shapesTopBtn');
const layersToggle = document.getElementById('layersToggle');

const layersFlyout = document.getElementById('layersFlyout');
const layersList = document.getElementById('layersList');
const addLayerBtn = document.getElementById('addLayerBtn');
const closeLayersBtn = document.getElementById('closeLayersBtn');
const raiseBtn = document.getElementById('raiseBtn');
const lowerBtn = document.getElementById('lowerBtn');
const deleteBtn = document.getElementById('deleteBtn');

let devicePixelRatioVal = window.devicePixelRatio || 1;

/* ====== Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ø¨Ù‚Ø§Øª ====== */
let layers = []; // [{id, canvas, ctx, name, visible, opacity}]
let activeLayerId = null;
const history = {};
const MAX_HISTORY = 30;

/* Ø£Ø¯ÙˆØ§Øª ÙˆØ£Ø´ÙƒØ§Ù„ */
let currentTool = 'brush'; // brush | eraser | shape
let currentShape = null; // rect|circle|line|arrow
let drawing = false;
let lastPoint = null;
let shapeStart = null;

/* ====== Ø£Ø¯ÙˆØ§Øª Ù…Ø³Ø§Ø¹Ø¯Ø© ====== */
function uid(){ return 'L'+Math.random().toString(36).slice(2,9); }
function getLayerById(id){ return layers.find(l=>l.id===id) || null; }
function getActiveLayer(){ return getLayerById(activeLayerId); }

/* Ø¥Ø¶Ø§ÙØ© Ø·Ø¨Ù‚Ø© */
function createLayer(name='Ø·Ø¨Ù‚Ø©'){
  const id = uid();
  const canvas = document.createElement('canvas');
  canvas.className = 'layer-canvas';
  canvas.dataset.layerId = id;
  // append to wrap (topmost at end)
  wrap.appendChild(canvas);
  const ctx = canvas.getContext('2d', { alpha:true });
  const layer = { id, canvas, ctx, name, visible:true, opacity:1 };
  layers.push(layer);
  history[id] = {undo:[], redo:[]};
  setActiveLayer(id);
  resizeAllCanvases();
  pushHistory(id);
  refreshLayersUI();
  return layer;
}

/* Ø­Ø°Ù Ø·Ø¨Ù‚Ø© */
function removeLayer(id){
  if (layers.length <= 1) { alert('Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø°Ù Ø§Ù„Ø·Ø¨Ù‚Ø© Ø§Ù„Ø£Ø®ÙŠØ±Ø©.'); return; }
  const idx = layers.findIndex(l=>l.id===id);
  if (idx===-1) return;
  const layer = layers[idx];
  wrap.removeChild(layer.canvas);
  delete history[id];
  layers.splice(idx,1);
  // Ø§Ø®ØªØ± Ø·Ø¨Ù‚Ø© Ø¬Ø¯ÙŠØ¯Ø© (Ø£Ø¹Ù„Ù‰)
  setActiveLayer(layers[layers.length-1].id);
  refreshLayersUI();
}

/* ØªØ¹ÙŠÙŠÙ† Ø·Ø¨Ù‚Ø© Ù†Ø´Ø·Ø© */
function setActiveLayer(id){
  activeLayerId = id;
  refreshLayersUI();
}

/* Ø±ÙØ¹/Ø®ÙØ¶ Ø·Ø¨Ù‚Ø© ÙÙŠ Ø§Ù„Ù…ØµÙÙˆÙØ© (ÙˆØ§Ù„Ù€ DOM) */
function raiseLayer(id){
  const idx = layers.findIndex(l=>l.id===id);
  if (idx <= 0) return;
  // swap Ø¨Ø§Ø§Ù„Ø·Ø¨Ù‚Ø© ÙÙˆÙ‚Ù‡ (ÙÙŠ Ø§Ù„Ù…ØµÙÙˆÙØ© ØªØ±ØªÙŠØ¨: 0=bottom ... last=top)
  [layers[idx-1], layers[idx]] = [layers[idx], layers[idx-1]];
  reorderCanvases();
  refreshLayersUI();
}
function lowerLayer(id){
  const idx = layers.findIndex(l=>l.id===id);
  if (idx === -1 || idx === layers.length-1) return;
  [layers[idx], layers[idx+1]] = [layers[idx+1], layers[idx]];
  reorderCanvases();
  refreshLayersUI();
}
function reorderCanvases(){
  // append in order bottom->top
  layers.forEach(l => wrap.appendChild(l.canvas));
}

/* ====== ØªØºÙŠÙŠØ± Ù…Ù‚Ø§Ø³ Ø§Ù„ÙƒØ§Ù†ÙØ§Ø³Ø§Øª Ù…Ø¹ Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ ====== */
function resizeAllCanvases(){
  const rect = wrap.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  devicePixelRatioVal = dpr;
  layers.forEach(l=>{
    const tmp = document.createElement('canvas');
    tmp.width = l.canvas.width;
    tmp.height = l.canvas.height;
    tmp.getContext('2d').drawImage(l.canvas,0,0);
    l.canvas.width = Math.floor(rect.width * dpr);
    l.canvas.height = Math.floor(rect.height * dpr);
    l.canvas.style.width = rect.width + 'px';
    l.canvas.style.height = rect.height + 'px';
    l.ctx.setTransform(dpr,0,0,dpr,0,0);
    if (tmp.width && tmp.height) l.ctx.drawImage(tmp,0,0,rect.width,rect.height);
    l.canvas.style.opacity = l.opacity || 1;
    l.canvas.style.display = l.visible ? 'block' : 'none';
  });
  // shape preview size
  shapePreview.width = Math.floor(rect.width * dpr);
  shapePreview.height = Math.floor(rect.height * dpr);
  shapePreview.style.width = rect.width + 'px';
  shapePreview.style.height = rect.height + 'px';
  shapePreview.getContext('2d').setTransform(dpr,0,0,dpr,0,0);
}

/* ====== ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø·Ø¨Ù‚Ø§Øª ====== */
function refreshLayersUI(){
  layersList.innerHTML = '';
  // show top layer first (list top = top visual)
  for (let i=layers.length-1;i>=0;i--){
    const l = layers[i];
    const item = document.createElement('div');
    item.className = 'layer-item' + (l.id===activeLayerId ? ' active' : '');
    item.dataset.id = l.id;

    const thumb = document.createElement('canvas'); thumb.className='layer-thumb';
    thumb.width = 88; thumb.height = 60;
    const tctx = thumb.getContext('2d');
    tctx.fillStyle = '#fff'; tctx.fillRect(0,0,thumb.width,thumb.height);
    if (l.canvas.width && l.canvas.height) tctx.drawImage(l.canvas,0,0,thumb.width,thumb.height);

    const nameDiv = document.createElement('div'); nameDiv.className='layer-name'; nameDiv.textContent = l.name;

    item.appendChild(thumb);
    item.appendChild(nameDiv);

    // click to select
    item.addEventListener('click', (e)=>{
      setActiveLayer(l.id);
      e.stopPropagation();
    });

    layersList.appendChild(item);
  }
}

/* ====== history per layer (undo/redo) ====== */
function pushHistory(layerId){
  if (!layerId) return;
  try {
    const l = getLayerById(layerId);
    const snap = l.canvas.toDataURL();
    const h = history[layerId];
    h.undo.push(snap);
    if (h.undo.length > MAX_HISTORY) h.undo.shift();
    h.redo = [];
    updateUndoRedo();
  } catch(e){ console.warn(e) }
}
function undo(layerId){
  const h = history[layerId];
  if (!h || h.undo.length===0) return;
  const last = h.undo.pop();
  h.redo.push(getLayerById(layerId).canvas.toDataURL());
  restoreLayerFromDataURL(layerId, last);
  updateUndoRedo();
}
function redo(layerId){
  const h = history[layerId];
  if (!h || h.redo.length===0) return;
  const next = h.redo.pop();
  h.undo.push(getLayerById(layerId).canvas.toDataURL());
  restoreLayerFromDataURL(layerId, next);
  updateUndoRedo();
}
function updateUndoRedo(){ undoBtn.disabled = !(activeLayerId && history[activeLayerId] && history[activeLayerId].undo.length>0); redoBtn.disabled = !(activeLayerId && history[activeLayerId] && history[activeLayerId].redo.length>0); }
function restoreLayerFromDataURL(layerId, dataURL){
  return new Promise((res,rej)=>{
    const img = new Image();
    img.onload = () => {
      const l = getLayerById(layerId);
      if (!l) return res();
      const rect = wrap.getBoundingClientRect();
      l.ctx.clearRect(0,0,rect.width,rect.height);
      l.ctx.drawImage(img,0,0,rect.width,rect.height);
      refreshLayersUI();
      res();
    };
    img.onerror = rej;
    img.src = dataURL;
  });
}

/* ====== Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø±Ø³Ù… Ùˆ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« ====== */
function setTool(t){ currentTool = t; brushBtn.setAttribute('aria-pressed', t==='brush'); eraserBtn.setAttribute('aria-pressed', t==='eraser'); }
brushBtn.addEventListener('click', ()=> setTool('brush'));
eraserBtn.addEventListener('click', ()=> setTool('eraser'));
function hexToRgba(hex, alpha=255){
  const c = hex.replace('#','');
  return [
    parseInt(c.substring(0,2),16),
    parseInt(c.substring(2,4),16),
    parseInt(c.substring(4,6),16),
    alpha
  ];
}

function floodFill(layer, startX, startY, fillColor){
  const ctx = layer.ctx;
  const dpr = devicePixelRatioVal || 1;
  const x = Math.floor(startX*dpr);
  const y = Math.floor(startY*dpr);
  const width = ctx.canvas.width;
  const height = ctx.canvas.height;

  const imgData = ctx.getImageData(0,0,width,height);
  const data = imgData.data;

  function colorMatch(idx,target){
    return data[idx]===target[0] &&
           data[idx+1]===target[1] &&
           data[idx+2]===target[2] &&
           data[idx+3]===target[3];
  }

  function setColor(idx,color){
    data[idx] = color[0];
    data[idx+1] = color[1];
    data[idx+2] = color[2];
    data[idx+3] = color[3];
  }

  const startIdx = (y*width + x)*4;
  const targetColor = [data[startIdx], data[startIdx+1], data[startIdx+2], data[startIdx+3]];
  const newColor = hexToRgba(fillColor);

  if(targetColor.toString() === newColor.toString()) return;

  const stack = [[x,y]];

  while(stack.length){
    const [cx,cy] = stack.pop();
    const idx = (cy*width + cx)*4;
    if(!colorMatch(idx,targetColor)) continue;
    setColor(idx,newColor);

    if(cx>0) stack.push([cx-1,cy]);
    if(cx<width-1) stack.push([cx+1,cy]);
    if(cy>0) stack.push([cx,cy-1]);
    if(cy<height-1) stack.push([cx,cy+1]);
  }

  ctx.putImageData(imgData,0,0);
}

// Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ Ø¹Ù†Ø¯ Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø¯Ù„Ùˆ
wrap.addEventListener('pointerdown', (ev)=>{
  if(currentTool==='fill'){
    const layer = getActiveLayer();
    if(!layer) return;
    const pos = pointerPosFromEvent(ev);
    floodFill(layer,pos.x,pos.y,colorPicker.value);
    pushHistory(layer.id);
  }
});
/* pointer positions */
function pointerPosFromEvent(e){
  const rect = wrap.getBoundingClientRect();
  const clientX = e.clientX !== undefined ? e.clientX : (e.touches && e.touches[0].clientX);
  const clientY = e.clientY !== undefined ? e.clientY : (e.touches && e.touches[0].clientY);
  return { x: clientX - rect.left, y: clientY - rect.top };
}

/* draw on ctx */
function drawLineOnCtx(ctx, from, to, width, color, erase=false){
  ctx.save();
  ctx.lineCap = 'round'; ctx.lineJoin = 'round';
  ctx.lineWidth = width;
  if (erase){
    ctx.globalCompositeOperation = 'destination-out';
    ctx.strokeStyle = 'rgba(0,0,0,1)';
  } else {
    ctx.globalCompositeOperation = 'source-over';
    ctx.strokeStyle = color;
  }
  ctx.beginPath();
  ctx.moveTo(from.x, from.y);
  ctx.lineTo(to.x, to.y);
  ctx.stroke();
  ctx.restore();
  ctx.globalAlpha = erase ? 1 : parseFloat(document.getElementById('brushAlpha').value);
}

/* attach pointer events to wrap and draw on active layer */
function attachPointerEvents(){
  wrap.onpointerdown = (ev)=>{
    ev.preventDefault();
    const layer = getActiveLayer(); if (!layer) return;
    drawing = true;
    lastPoint = pointerPosFromEvent(ev);
    shapeStart = pointerPosFromEvent(ev);
    if (currentTool === 'brush' || currentTool === 'eraser' || currentTool === 'shape') pushHistory(layer.id);
  };
  wrap.onpointermove = (ev)=>{
    const pos = pointerPosFromEvent(ev);
    const layer = getActiveLayer(); if (!layer) return;
    if (!drawing) return;
    if (currentTool === 'brush' || currentTool === 'eraser'){
      drawLineOnCtx(layer.ctx, lastPoint, pos, parseInt(sizeRange.value,10), colorPicker.value, currentTool==='eraser');
      lastPoint = pos;
    } else if (currentTool === 'shape' && currentShape){
      drawShapePreview(shapeStart, pos, currentShape, colorPicker.value, parseInt(sizeRange.value,10));
    }
  };
  wrap.onpointerup = (ev)=>{
    const pos = pointerPosFromEvent(ev);
    const layer = getActiveLayer(); if (!layer) return;
    if (!drawing) return;
    if (currentTool === 'shape' && currentShape){
      commitShapeToLayer(layer, shapeStart, pos, currentShape, colorPicker.value, parseInt(sizeRange.value,10));
      clearPreview();
    }
    drawing = false; lastPoint = null; shapeStart = null;
    updateUndoRedo();
  };
  wrap.onpointercancel = ()=> { drawing=false; clearPreview(); lastPoint=null; shapeStart=null; };
}
attachPointerEvents();

/* shape preview */
function clearPreview(){ const ctx = shapePreview.getContext('2d'); const rect = wrap.getBoundingClientRect(); ctx.clearRect(0,0,rect.width,rect.height); }
function drawShapePreview(from, to, shape, color, lineWidth){
  const ctx = shapePreview.getContext('2d');
  const rect = wrap.getBoundingClientRect();
  ctx.clearRect(0,0,rect.width,rect.height);
  ctx.save();
  ctx.lineWidth = lineWidth; ctx.strokeStyle = color; ctx.fillStyle = color; ctx.lineCap='round'; ctx.lineJoin='round';
  if (shape === 'rect'){
    const x = Math.min(from.x,to.x), y = Math.min(from.y,to.y), w = Math.abs(to.x-from.x), h = Math.abs(to.y-from.y);
    ctx.strokeRect(x,y,w,h);
  } else if (shape === 'circle'){
    const cx=(from.x+to.x)/2, cy=(from.y+to.y)/2, rx=Math.abs(to.x-from.x)/2, ry=Math.abs(to.y-from.y)/2;
    ctx.beginPath(); ctx.ellipse(cx,cy,rx,ry,0,0,Math.PI*2); ctx.stroke();
  } else if (shape === 'line'){
    ctx.beginPath(); ctx.moveTo(from.x,from.y); ctx.lineTo(to.x,to.y); ctx.stroke();
  } else if (shape === 'arrow'){
    drawArrowOnCtx(ctx, from, to, lineWidth);
  }
  ctx.restore();
}
function drawArrowOnCtx(ctx, from, to, lineWidth){
  ctx.beginPath(); ctx.moveTo(from.x,from.y); ctx.lineTo(to.x,to.y); ctx.stroke();
  const angle = Math.atan2(to.y-from.y,to.x-from.x);
  const headlen = Math.max(8, lineWidth*1.5);
  ctx.beginPath();
  ctx.moveTo(to.x,to.y);
  ctx.lineTo(to.x - headlen*Math.cos(angle - Math.PI/6), to.y - headlen*Math.sin(angle - Math.PI/6));
  ctx.lineTo(to.x - headlen*Math.cos(angle + Math.PI/6), to.y - headlen*Math.sin(angle + Math.PI/6));
  ctx.lineTo(to.x,to.y);
  ctx.fill();
}
function commitShapeToLayer(layer, from, to, shape, color, lineWidth){
  const ctx = layer.ctx;
  ctx.save();
  ctx.lineWidth = lineWidth; ctx.strokeStyle = color; ctx.fillStyle = color; ctx.lineCap='round'; ctx.lineJoin='round';
  if (shape === 'rect'){
    const x = Math.min(from.x,to.x), y = Math.min(from.y,to.y), w = Math.abs(to.x-from.x), h = Math.abs(to.y-from.y);
    ctx.strokeRect(x,y,w,h);
  } else if (shape === 'circle'){
    const cx=(from.x+to.x)/2, cy=(from.y+to.y)/2, rx=Math.abs(to.x-from.x)/2, ry=Math.abs(to.y-from.y)/2;
    ctx.beginPath(); ctx.ellipse(cx,cy,rx,ry,0,0,Math.PI*2); ctx.stroke();
  } else if (shape === 'line'){
    ctx.beginPath(); ctx.moveTo(from.x,from.y); ctx.lineTo(to.x,to.y); ctx.stroke();
  } else if (shape === 'arrow'){
    drawArrowOnCtx(ctx, from, to, lineWidth);
  }
  ctx.restore();
}

/* ====== ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø£Ø²Ø±Ø§Ø± ====== */
/* shapesTopBtn ÙŠÙØªØ­ Ù‚Ø§Ø¦Ù…Ø© Ø£Ø´ÙƒØ§Ù„ Ø¨Ø³ÙŠØ·Ø© Ù…Ø¹ Ø­ÙØ¸ ÙˆØ§Ø³ØªÙŠØ±Ø§Ø¯ ØµÙˆØ±Ø© */
let shapesMenu = null;
shapesTopBtn.addEventListener('click', (e)=>{
  // if menu exists, toggle
  if (shapesMenu && document.body.contains(shapesMenu)){ shapesMenu.remove(); shapesMenu=null; return; }
  shapesMenu = document.createElement('div');
  shapesMenu.style.position='absolute';
  shapesMenu.style.top = (shapesTopBtn.getBoundingClientRect().bottom + 8) + 'px';
  shapesMenu.style.right = (window.innerWidth - shapesTopBtn.getBoundingClientRect().right) + 'px';
  shapesMenu.style.background = 'white';
  shapesMenu.style.borderRadius='8px';
  shapesMenu.style.boxShadow='0 8px 20px rgba(0,0,0,0.15)';
  shapesMenu.style.padding='8px';
  shapesMenu.style.zIndex = 1300;
  shapesMenu.innerHTML = `
    <div style="font-weight:7000;margin-bottom:10px;text-align:right">Ø£Ø¯ÙˆØ§Øª</div>
    <div style="margin-top:6px;border-top:1px solid #ddd;padding-top:6px">
    
    <button data-shape="rect" style="display:block;width:100%;margin-bottom:1px">Ù…Ø±Ø¨Ø¹</button>
    <button data-shape="circle" style="display:block;width:100%;margin-bottom:1px">Ø¯Ø§Ø¦Ø±Ø©</button>
    <button data-shape="line" style="display:block;width:100%;margin-bottom:6px">Ø®Ø·</button>

    <div style="margin-top:6px;border-top:1px solid #ddd;padding-top:6px">
      <button id="importBtn" style="display:block;width:100%;margin-bottom:6px">Ø§Ø³ØªÙŠØ±Ø§Ø¯</button>
      <button id="saveInsideBtn" style="display:block;width:100%">Ø­ÙØ¸</button>
    </div>
  `;
  document.body.appendChild(shapesMenu);

  // Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø£Ø´ÙƒØ§Ù„ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠØ©
  shapesMenu.querySelectorAll('button[data-shape]').forEach(b=>{
    b.addEventListener('click', ()=>{
      currentTool = 'shape';
      currentShape = b.dataset.shape;
      shapesMenu.remove(); shapesMenu = null;
    });
  });

  // Ø²Ø± Ø­ÙØ¸ Ø¯Ø§Ø®Ù„ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
  // Ø²Ø± Ø­ÙØ¸ Ø¯Ø§Ø®Ù„ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
document.getElementById('saveInsideBtn').addEventListener('click', ()=>{
  saveDrawing();   // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„ÙˆØ¸ÙŠÙØ© Ù…Ø¨Ø§Ø´Ø±Ø©
  shapesMenu.remove();
  shapesMenu = null;
});

  // Ø²Ø± Ø§Ø³ØªÙŠØ±Ø§Ø¯ ØµÙˆØ±Ø©
  document.getElementById('importBtn').addEventListener('click', ()=>{
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.onchange = (e)=>{
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(ev){
        const img = new Image();
        img.onload = function(){
          const layer = getActiveLayer();
          if (!layer) return;
          const rect = wrap.getBoundingClientRect();
          layer.ctx.drawImage(img, 0, 0, rect.width, rect.height);
          pushHistory(layer.id);
        };
        img.src = ev.target.result;
      };
      reader.readAsDataURL(file);
    };
    input.click();
    shapesMenu.remove(); shapesMenu = null;
  });

  // Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¹Ù†Ø¯ Ø§Ù„Ø¶ØºØ· Ø®Ø§Ø±Ø¬Ù‡Ø§
  document.addEventListener('click', function onDocClick(evt){
    if (!shapesMenu) return;
    if (!shapesMenu.contains(evt.target) && evt.target !== shapesTopBtn) {
      shapesMenu.remove(); shapesMenu=null;
      document.removeEventListener('click', onDocClick);
    }
  });
});

/* layers toggle */
layersToggle.addEventListener('click', (e)=>{
  layersFlyout.classList.toggle('open');
  layersFlyout.setAttribute('aria-hidden', !layersFlyout.classList.contains('open'));
});

/* close layers */
closeLayersBtn.addEventListener('click', ()=> { layersFlyout.classList.remove('open'); layersFlyout.setAttribute('aria-hidden','true'); });

/* click outside closes layers flyout */
document.addEventListener('click', (e)=>{
  if (!layersFlyout.classList.contains('open')) return;
  const isInside = layersFlyout.contains(e.target) || layersToggle.contains(e.target);
  if (!isInside) { layersFlyout.classList.remove('open'); layersFlyout.setAttribute('aria-hidden','true'); }
});

/* add layer */
addLayerBtn.addEventListener('click', ()=> createLayer('Ø·Ø¨Ù‚Ø© ' + (layers.length + 1)));

/* raise/lower/delete operate on active layer */
raiseBtn.addEventListener('click', ()=> { if (!activeLayerId) return; raiseLayer(activeLayerId); });
lowerBtn.addEventListener('click', ()=> { if (!activeLayerId) return; lowerLayer(activeLayerId); });
deleteBtn.addEventListener('click', ()=> { if (!activeLayerId) return; const ok = confirm('Ø­Ø°Ù Ø§Ù„Ø·Ø¨Ù‚Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©ØŸ'); if (ok) removeLayer(activeLayerId); });

/* undo/redo/clear/save */
undoBtn.addEventListener('click', ()=> { if (activeLayerId) undo(activeLayerId); });
redoBtn.addEventListener('click', ()=> { if (activeLayerId) redo(activeLayerId); });
clearBtn.addEventListener('click', ()=> {
  if (!activeLayerId) return;
  const layer = getActiveLayer(); if (!layer) return;
  pushHistory(layer.id);
  const rect = wrap.getBoundingClientRect();
  layer.ctx.clearRect(0,0,rect.width,rect.height);
});
saveBtn.addEventListener('click', ()=> {
  const rect = wrap.getBoundingClientRect();
  const tmp = document.createElement('canvas');
  tmp.width = Math.round(rect.width * devicePixelRatioVal);
  tmp.height = Math.round(rect.height * devicePixelRatioVal);
  tmp.style.width = rect.width+'px'; tmp.style.height = rect.height+'px';
  const tctx = tmp.getContext('2d'); tctx.setTransform(devicePixelRatioVal,0,0,devicePixelRatioVal,0,0);
  tctx.fillStyle = '#ffffff'; tctx.fillRect(0,0,rect.width,rect.height);
  // bottom->top
  for (let i=0;i<layers.length;i++){
    const l = layers[i];
    if (!l.visible) continue;
    tctx.globalAlpha = l.opacity || 1;
    tctx.drawImage(l.canvas,0,0,rect.width,rect.height);
  }
  tmp.toBlob(blob=>{
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'drawing.png';
    a.click();
    URL.revokeObjectURL(a.href);
  }, 'image/png');
});

/* keyboard */
window.addEventListener('keydown', (e)=>{
  if (e.ctrlKey || e.metaKey){
    if (e.key === 'z') { if (activeLayerId) undo(activeLayerId); e.preventDefault(); }
    if (e.key === 'y') { if (activeLayerId) redo(activeLayerId); e.preventDefault(); }
  }
  if (e.key === 'b') setTool('brush');
  if (e.key === 'e') setTool('eraser');
});

/* prevent scroll while drawing */
document.body.addEventListener('touchstart', (e)=>{ if (e.target.closest('.canvas-wrap')) e.preventDefault(); }, {passive:false});
document.body.addEventListener('touchmove', (e)=>{ if (e.target.closest('.canvas-wrap')) e.preventDefault(); }, {passive:false});

/* resize: Ø­ÙØ¸ Ø§Ø³ØªÙŠØª Ø«Ù… Ø§Ø³ØªØ¹Ø§Ø¯Ø© */
let resizeTimer = null;
window.addEventListener('resize', ()=>{
  if (resizeTimer) clearTimeout(resizeTimer);
  const snaps = {};
  layers.forEach(l => { snaps[l.id] = l.canvas.toDataURL(); });
  resizeTimer = setTimeout(async ()=>{
    resizeAllCanvases();
    for (const id in snaps) await restoreLayerFromDataURL(id, snaps[id]);
    resizeTimer = null;
  }, 140);
});

/* initialize Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ */
function init(){
  createLayer('Ø®Ù„ÙÙŠØ©');
  createLayer('Ø§Ù„Ø·Ø¨Ù‚Ø© 1');
  resizeAllCanvases();
  setActiveLayer(layers[layers.length-1].id);
  refreshLayersUI();
  updateUndoRedo();
  // shapePreview styling
  const rect = wrap.getBoundingClientRect();
  shapePreview.style.left='0'; shapePreview.style.top='0';
  shapePreview.style.width = rect.width + 'px';
  shapePreview.style.height = rect.height + 'px';
  const layerAlphaInput = document.getElementById('layerAlpha');
layerAlphaInput.addEventListener('input', ()=>{
  const layer = getActiveLayer();
  if(!layer) return;
  layer.opacity = parseFloat(layerAlphaInput.value);
  layer.canvas.style.opacity = layer.opacity;
});
}
window.addEventListener('DOMContentLoaded', () => {
    init();
});

</script>
</body>
</html>